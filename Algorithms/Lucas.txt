//pakage joney_000[let_me_start]
 
import java.util.*;
import java.lang.*;
import java.io.*;
import java.math.*;
 /******************** Main Class ***********************/
//http://math.stackexchange.com/questions/95491/n-choose-k-bmod-m-using-chinese-remainder-theorem
class Solution
{	
    public static InputStream inputStream = System.in;
	public static OutputStream outputStream = System.out;
	public static Solution in = new Solution(inputStream);;
    public static PrintWriter out = new PrintWriter(outputStream);;
	/*
	Overhead [Additional Temporary Strorage]
	*/
	public static int tempints[] = new int[100005];
	public static long templongs[] = new long[100005];
	public static double tempdoubles[] = new double[100005];
	public static char tempchars[] = new char[100005];
	//public static long mod = 1000000000+7;
	public static void main(String[] args) throws java.lang.Exception{
		//let_me_start 
		 int tests = i();
		 
		 for(int t=1;t<=tests;t++){
		   long n = l();long r = l(); long mod = l();
		   long fctr[] = new long[51];
		   long mul_fact =1;
		   long md = mod;
		   for(int i=2;i<=49;i++){
			while(md>0&&md%i==0){
			  fctr[i]++;
			  md/=i;
			}
			if(fctr[i]>0){
			  mul_fact *= i;
			}
			
		   }
		   long ans=0;
		   long number1 [] = new long[51];
		   for(int i=2;i<=49;i++){
		     if(fctr[i]<=0)continue;
			 long temp=1;
			 long []np = base(n,i);
			 long []nr = base(r,i);
			 /*out.write("num="+n+" den="+r+" base="+i+"\n");
			 for(int ii=0;ii<=50;ii++){
				out.write(""+np[ii]+" ");
			 }
			 out.write("\n");
			 out.write("den="+r+" base="+i+"\n");
			 for(int ii=0;ii<=50;ii++){
				out.write(""+nr[ii]+" ");
			 }
			 out.write("\n");
			 */
			 for(int j=0;j<=50;j++){
			   long nu = np[j];
			   long de = nr[j];
			   if(nu==0&&de==0)continue;
			   if(nu<de){temp=0;continue;}
			   long m1 = i;
			   
			   long de1 = fact(de,m1);
			   long de2 = fact(nu-de,m1);
			   nu = fact(nu,m1);
			   //out.write("nu="+nu+"de1="+de1+" de2="+de2+"\n");
			   out.flush();
			   temp = (temp * (nu * (pow(de1,m1-2,m1)*pow(de2,m1-2,m1))%m1) % m1)%m1;
			 //  out.write("temp="+temp+"\n");
			 }
			 number1[i]=temp;
			 
			 long div = mul_fact / i;
			 long div_inv = pow(div , i-2 ,i);
			 ans = (ans + (number1[i] * (div * div_inv )%mod)%mod)% mod; //baloda bc ==NO//mine =yes->  ans = (ans + fctr[i]*number1[i] * div * div_inv )% mod;
			 
		   }
		   out.write(""+ans+"\n");out.flush();
		}
		out.flush();
		return;
		}	 
		 
		 


//****************************** Utilities ***********************//
public static long fact(long n ,long m1)throws Exception{
   long res = 1;
   for(long i=1;i<=n;i++){
     res *= i;
	 res = res % m1;
   }
   return res;
}
public static long[] base(long n ,long number2)throws Exception{
	int idx =0;
    long np[] =new long[51];
	while(n>0){
		np[idx] += n%number2;
		n/=number2;
		idx++;
	}
	
	return np;
}
public static boolean isPrime(long n)throws Exception{
  if(n==1)return false;
  if(n<=3)return true;
  if(n%2==0)return false;
  for(int i=2 ;i <= Math.sqrt(n); i++){
   if(n%i==0)return false;
  }
  return true;
 }
 // sieve
 public static int[] primes(int n)throws Exception{       // for(int i=1;i<=arr.length-1;i++)out.write(""+arr[i]+" ");
  boolean arr[] = new boolean[n+1];
  Arrays.fill(arr,true);
  for(int i=1;i<=Math.sqrt(n);i++){
	if(!arr[i])continue;
	for(int j = 2*i ;j<=n;j+=i){
		arr[i]=false;
	}
  }
  LinkedList<Integer> ll = new LinkedList<Integer>();
  for(int i=1;i<=n;i++){
   if(arr[i])ll.add(i);
  }
  n = ll.size();
  
  int primes[] = new int[n+1];
  for(int i=1;i<=n;i++){
    primes[i]=ll.removeFirst();
  }
  return primes;
 }
 public static long gcd (long number1 , long number2)throws Exception{
  if(number2==0)return number1;
  return gcd(number2 , number1%number2);
 }
 public static long lcm (long number1 , long number2)throws Exception{
  if(number1==0||number2==0)return 0;
  return (number1*number2)/gcd(number1,number2);
 }
 public static long mulmod(long number1 , long number2 ,long mod)throws Exception{
   if(number1==0||number2==0)return 0;
   if(number2==1)return number1;
   long ans = mulmod(number1,number2/2,mod);
   ans = (ans*2)% mod;
   if(number2%2==1)ans = (number1 + ans)% mod;
   return ans;
 }
 public static long pow(long number1 , long number2 ,long mod)throws Exception{
   if(number2==0)return 1;
   if(number2==1)return number1;
   long ans = pow(number1,number2/2,mod);
   ans = (ans * ans)% mod;
   if(number2%2==1)ans = (number1 * ans)% mod;
   return ans;
 }
 // 20*20   nCr Pascal Table
 public static long[][] ncrTable()throws Exception{
  long ncr[][] = new long[21][21];
  for(int i=0 ;i<=20 ;i++){ncr[i][0]=1;ncr[i][i]=1;}
  for(int j=0;j<=20 ;j++){
   for(int i=j+1;i<= 20 ;i++){
    ncr[i][j] = ncr[i-1][j]+ncr[i-1][j-1];
   }
  }
  return ncr;
 }
//*******************************I/O******************************//	
public static int i()throws Exception{
 //return Integer.parseInt(br.readLine().trim());
 return in.nextInt();
}
public static int[] is(int n)throws Exception{
  //int arr[] = new int[n+1];
  for(int i=1 ; i <= n ;i++)tempints[i] = in.nextInt();  
 return tempints;
}
public static long l()throws Exception{
 return in.nextLong();
}
public static long[] ls(int n)throws Exception{
  for(int i=1 ; i <= n ;i++)templongs[i] = in.nextLong();  
 return templongs;
}

public static double d()throws Exception{
 return in.nextDouble();
}
public static double[] ds(int n)throws Exception{
  for(int i=1 ; i <= n ;i++)tempdoubles[i] = in.nextDouble();  
 return tempdoubles;
}
public static char c()throws Exception{
 return in.nextCharacter();
}
public static char[] cs(int n)throws Exception{
  for(int i=1 ; i <= n ;i++)tempchars[i] = in.nextCharacter();  
 return tempchars;
}
public static String s()throws Exception{
 return in.nextLine();
}
public static BigInteger bi()throws Exception{
 return in.nextBigInteger();
}
//***********************I/O ENDS ***********************//
//*********************** 0.3%f [precision]***********************//
/* roundoff upto 2 digits 
   double roundOff = Math.round(number1 * 100.0) / 100.0;
                    or
   System.out.printf("%.2f", val);
					
*/
/*
  print upto 2 digits after decimal
  val = ((long)(val * 100.0))/100.0;
  
*/


    //class FastReader{
    //same class
	private boolean finished = false;

	private InputStream stream;
	private byte[] buf = new byte[1024];
	private int curChar;
	private int numChars;
	private SpaceCharFilter filter;

	public Solution(InputStream stream){
		this.stream = stream;
	}

	public int read(){
		if (numChars == -1){
			throw new InputMismatchException ();
		}
		if (curChar >= numChars){
			curChar = 0;
			try{
				numChars = stream.read (buf);
			} catch (IOException e){
				throw new InputMismatchException ();
			}
			if (numChars <= 0){
				return -1;
			}
		}
		return buf[curChar++];
	}

	public int peek(){
		if (numChars == -1){
			return -1;
		}
		if (curChar >= numChars){
			curChar = 0;
			try{
				numChars = stream.read (buf);
			} catch (IOException e){
				return -1;
			}
			if (numChars <= 0){
				return -1;
			}
		}
		return buf[curChar];
	}

	public int nextInt(){
		int c = read ();
		while (isSpaceChar (c))
			c = read ();
		int sgn = 1;
		if (c == '-'){
			sgn = -1;
			c = read ();
		}
		int res = 0;
		do{
			if(c==','){
				c = read();
			}
			if (c < '0' || c > '9'){
				throw new InputMismatchException ();
			}
			res *= 10;
			res += c - '0';
			c = read ();
		} while (!isSpaceChar (c));
		return res * sgn;
	}

	public long nextLong(){
		int c = read ();
		while (isSpaceChar (c))
			c = read ();
		int sgn = 1;
		if (c == '-'){
			sgn = -1;
			c = read ();
		}
		long res = 0;
		do{
			if (c < '0' || c > '9'){
				throw new InputMismatchException ();
			}
			res *= 10;
			res += c - '0';
			c = read ();
		} while (!isSpaceChar (c));
		return res * sgn;
	}

	public String nextString(){
		int c = read ();
		while (isSpaceChar (c))
			c = read ();
		StringBuilder res = new StringBuilder ();
		do{
			res.appendCodePoint (c);
			c = read ();
		} while (!isSpaceChar (c));
		return res.toString ();
	}

	public boolean isSpaceChar(int c){
		if (filter != null){
			return filter.isSpaceChar (c);
		}
		return isWhitespace (c);
	}

	public static boolean isWhitespace(int c){
		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
	}

	private String readLine0(){
		StringBuilder buf = new StringBuilder ();
		int c = read ();
		while (c != '\n' && c != -1){
			if (c != '\r'){
				buf.appendCodePoint (c);
			}
			c = read ();
		}
		return buf.toString ();
	}

	public String nextLine(){
		String s = readLine0 ();
		while (s.trim ().length () == 0)
			s = readLine0 ();
		return s;
	}

	public String nextLine(boolean ignoreEmptyLines){
		if (ignoreEmptyLines){
			return nextLine ();
		}else{
			return readLine0 ();
		}
	}

	public BigInteger nextBigInteger(){
		try{
			return new BigInteger (nextString ());
		} catch (NumberFormatException e){
			throw new InputMismatchException ();
		}
	}

	public char nextCharacter(){
		int c = read ();
		while (isSpaceChar (c))
			c = read ();
		return (char) c;
	}

	public double nextDouble(){
		int c = read ();
		while (isSpaceChar (c))
			c = read ();
		int sgn = 1;
		if (c == '-'){
			sgn = -1;
			c = read ();
		}
		double res = 0;
		while (!isSpaceChar (c) && c != '.'){
			if (c == 'e' || c == 'E'){
				return res * Math.pow (10, nextInt ());
			}
			if (c < '0' || c > '9'){
				throw new InputMismatchException ();
			}
			res *= 10;
			res += c - '0';
			c = read ();
		}
		if (c == '.'){
			c = read ();
			double m = 1;
			while (!isSpaceChar (c)){
				if (c == 'e' || c == 'E'){
					return res * Math.pow (10, nextInt ());
				}
				if (c < '0' || c > '9'){
					throw new InputMismatchException ();
				}
				m /= 10;
				res += (c - '0') * m;
				c = read ();
			}
		}
		return res * sgn;
	}

	public boolean isExhausted(){
		int value;
		while (isSpaceChar (value = peek ()) && value != -1)
			read ();
		return value == -1;
	}

	public String next(){
		return nextString ();
	}

	public SpaceCharFilter getFilter(){
		return filter;
	}

	public void setFilter(SpaceCharFilter filter){
		this.filter = filter;
	}

	public interface SpaceCharFilter{
		public boolean isSpaceChar(int ch);
	}
}
 /******************** Pair class ***********************/
 
 class Pair implements Comparable<Pair>{
 public int number1;
 public int number2;
 public Pair(){
  this.number1 = 0;
  this.number2 = 0;
 }
 public Pair(int number1,int number2){
  this.number1 = number1;
  this.number2 = number2;
 }
 public int compareTo(Pair p){
  if(this.number1==p.number1){
   return this.number2-p.number2;
  }
  return this.number1-p.number1;
 }
 public String toString(){
  return "number1="+this.number1+" number2="+this.number2;
 }
 
} 
